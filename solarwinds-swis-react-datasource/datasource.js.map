{"version":3,"file":"datasource.js","mappings":"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","sources":["webpack://solarwinds-swis-react-datasource/external amd \"rxjs\"","webpack://solarwinds-swis-react-datasource/external amd \"@grafana/runtime\"","webpack://solarwinds-swis-react-datasource/external amd \"@grafana/data\"","webpack://solarwinds-swis-react-datasource/webpack/bootstrap","webpack://solarwinds-swis-react-datasource/webpack/runtime/compat get default export","webpack://solarwinds-swis-react-datasource/webpack/runtime/define property getters","webpack://solarwinds-swis-react-datasource/webpack/runtime/hasOwnProperty shorthand","webpack://solarwinds-swis-react-datasource/webpack/runtime/make namespace object","webpack://solarwinds-swis-react-datasource/./datasource.ts"],"sourcesContent":["module.exports = __WEBPACK_EXTERNAL_MODULE__269__;","module.exports = __WEBPACK_EXTERNAL_MODULE__531__;","module.exports = __WEBPACK_EXTERNAL_MODULE__781__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  MutableDataFrame,\n  FieldType,\n  MetricFindValue,\n  ScopedVars,\n} from '@grafana/data';\nimport { getBackendSrv, getTemplateSrv } from '@grafana/runtime';\nimport { lastValueFrom } from 'rxjs';\nimport _ from 'lodash';\nimport { SwisQuery, SwisDataSourceOptions, QueryMetadata, Column } from './types';\n\nexport class SwisDatasource extends DataSourceApi<SwisQuery, SwisDataSourceOptions> {\n  url: string;\n  withCredentials: boolean;\n  headers: Record<string, string>;\n\n  constructor(instanceSettings: DataSourceInstanceSettings<SwisDataSourceOptions>) {\n    super(instanceSettings);\n    this.url = instanceSettings.url || '';\n    this.withCredentials = instanceSettings.withCredentials || false;\n    this.headers = { 'Content-Type': 'application/json' };\n    if (typeof instanceSettings.basicAuth === 'string' && instanceSettings.basicAuth.length > 0) {\n      this.headers['Authorization'] = instanceSettings.basicAuth;\n    }\n  }\n\n  async testDatasource() {\n    try {\n      const response = await this.doRequest({\n        url: this.url + '/Query?query=SELECT Description FROM System.NullEntity',\n        method: 'GET',\n      });\n      \n      if (response.status === 200) {\n        return {\n          status: 'success',\n          message: 'Data source is working :)',\n          title: 'Success',\n        };\n      }\n      \n      return {\n        status: 'error',\n        message: `Error connecting to SWIS: ${response.statusText}`,\n        title: 'Error',\n      };\n    } catch (err) {\n      return {\n        status: 'error',\n        message: `Error connecting to SWIS: ${err}`,\n        title: 'Error',\n      };\n    }\n  }\n\n  interpolateVariable(value: any, variable: any) {\n    if (typeof value === 'string') {\n      if (variable.multi || variable.includeAll) {\n        return \"'\" + value.replace(/'/g, `''`) + \"'\";\n      } else {\n        return value;\n      }\n    }\n\n    if (typeof value === 'number') {\n      return value;\n    }\n\n    return value;\n  }\n\n  async query(options: DataQueryRequest<SwisQuery>): Promise<DataQueryResponse> {\n    const queries = options.targets\n      .filter(item => !item.hide)\n      .map(item => {\n        return {\n          refId: item.refId,\n          intervalMs: options.intervalMs,\n          maxDataPoints: options.maxDataPoints,\n          rawSql: item.rawSql,\n          format: item.format,\n        };\n      });\n\n    if (queries.length === 0) {\n      return { data: [] };\n    }\n\n    try {\n      const promises = queries.map(query => this.doQuery(query, options));\n      const results = await Promise.all(promises);\n      const data = results.flat();\n      \n      return { data };\n    } catch (error) {\n      console.error('Query error:', error);\n      throw error;\n    }\n  }\n\n  async doQuery(query: any, options: DataQueryRequest<SwisQuery>) {\n    // Process SWQL\n    let swql = query.rawSql;\n    swql = swql.replace(/\\$from/g, '@timeFrom');\n    swql = swql.replace(/\\$to/g, '@timeTo');    \n\n    swql = getTemplateSrv().replace(swql, options.scopedVars, this.interpolateVariable);\n\n    query.rawSql = swql;    \n\n    const param = {\n      query: this.resolveMacros(query.rawSql, options),\n      parameters: {\n        timeFrom: options.range ? options.range.from.toISOString() : '',\n        timeTo: options.range ? options.range.to.toISOString() : '',\n        granularity: Math.max(Math.floor((options.intervalMs || 0) / 1000), 1),\n      }\n    };    \n    \n    query.options = options;\n\n    try {\n      // First get metadata\n      const metadataResponse = await this.doRequest({\n        url: this.url + '/Query', \n        method: 'POST',\n        data: {\n          query: param.query + \" WITH SCHEMAONLY\",\n          parameters: param.parameters\n        }\n      });\n      \n      this.processMetadata(metadataResponse, query);\n      \n      // Then get the actual data\n      const dataResponse = await this.doRequest({\n        url: this.url + '/Query', \n        method: 'POST',\n        data: param\n      });\n      \n      return this.processQueryResult(dataResponse, query);\n    } catch (error) {\n      console.error('Error executing query:', error);\n      throw error;\n    }\n  }\n\n  timeSpan(ms: number): string {\n    const obj = {\n      ms: ms % 1000,\n      ss: Math.floor(ms / 1000) % 60,\n      mm: Math.floor(ms / (1000 * 60)) % 60,\n      hh: Math.floor(ms / (1000 * 60 * 60)) % 24,\n      dd: Math.floor(ms / (1000 * 60 * 60 * 24))\n    };\n    return obj.dd + '.' + obj.hh + ':' + obj.mm + ':' + obj.ss + '.' + obj.ms;\n  }\n\n  resolveMacros(rawSql: string, options: DataQueryRequest<SwisQuery>): string {\n    // downsample(variable) is translated into - ADDSECOND(FLOOR(SecondDiff('1970-01-01T00:00:00', LastSync) / [granularity] + 1) * [granularity], '1970-01-01T00:00:00')\n    const r = /downsample\\(([^\\)]*)*\\)/g;\n\n    rawSql = rawSql.replace(r, (match, group) => {\n      return \"ADDSECOND(FLOOR(SecondDiff('1970-01-01T00:00:00', \"+group+\")/@granularity+1)*@granularity, '1970-01-01T00:00:00')\";\n    });\n    \n    // add sampling to all queries as it's harmless\n    if (rawSql.indexOf('GRANULARITY') === -1 && rawSql.indexOf('downsample') !== -1) {\n      rawSql += \" WITH GRANULARITY '\" + this.timeSpan(options.intervalMs || 0) + \"'\";\n    }\n\n    return rawSql;\n  }\n\n  processMetadata(res: any, query: any): void {\n    const columns: Column[] = [];\n    const metadata: QueryMetadata = {\n      timeColumnIndex: -1,\n      metricIndex: -1,\n      columns: columns\n    };\n\n    for (const row of res.data.results) {\n      if (row.DataType.indexOf('String') !== -1) {\n        metadata.metricIndex = row.Index;\n      } else if (row.DataType.indexOf('DateTime') !== -1) {\n        metadata.timeColumnIndex = row.Index;\n      }      \n\n      columns.push({\n        index: row.Index,\n        name: row.Alias,\n        type: this.translateType(row.DataType)\n      });\n    }\n\n    // metric has limitations on data output\n    if (query.format === 'time_series') {\n      if (columns.length < 2) {\n        throw new Error('There has to be at least 2 columns defined for Series');\n      }\n\n      if (metadata.timeColumnIndex === -1) {\n        throw new Error('Missing DateTime column which is needed for Series');\n      }\n    }\n\n    // set metadata to query\n    query.metadata = metadata;\n  }\n\n  translateType(type: string): string {\n    // Translate SWIS type to grafana types\n    if (type.indexOf('Int') !== -1 || type.indexOf('Double') !== -1 || type.indexOf('Decimal') !== -1) {\n      return FieldType.number;\n    } else if (type.indexOf('DateTime') !== -1) {\n      return FieldType.time;\n    } else if (type.indexOf('Boolean') !== -1) {\n      return FieldType.boolean;\n    }\n    return FieldType.string;\n  }\n\n  processQueryResult(res: any, query: any) {\n    if (query.format === 'table') {\n      return this.processQueryResultTable(res, query);\n    }\n    else if (query.format === 'time_series') {\n      return this.processQueryResultMetric(res, query);\n    }\n    else if (query.format === 'search') {\n      return this.processQueryResultSearch(res, query);\n    }\n    else if (query.format === 'annotation') {\n      return this.processQueryResultAnnotation(res, query);\n    }\n    else {    \n      throw new Error('Unknown query format [' + query.format + ']');\n    }\n  }\n\n  processQueryResultAnnotation(res: any, query: any) {\n    const metadata = query.metadata;\n    let timeIndex = metadata.columns.findIndex((n: Column) => n.name === 'time');\n    if (timeIndex === -1) timeIndex = metadata.timeColumnIndex;\n    \n    let textIndex = metadata.columns.findIndex((n: Column) => n.name === 'text');\n    if (textIndex === -1) textIndex = metadata.metricIndex;\n    \n    const tagsIndex = metadata.columns.findIndex((n: Column) => n.name === 'tags');\n\n    if (timeIndex === -1) {\n      throw new Error('Missing mandatory column DateTime column or named [time]');\n    }\n\n    return res.data.results.map((rowData: any) => \n      Object.keys(rowData).map(n => rowData[n])\n    ).map((row: any) => {\n      return {\n        annotation: query.options.annotation,\n        time: this.correctTime(row[timeIndex]),\n        text: row[textIndex],\n        tags: row[tagsIndex] ? row[tagsIndex].trim().split(/\\s*,\\s*/) : []\n      };\n    });\n  }\n\n  processQueryResultSearch(res: any, query: any): MetricFindValue[] {\n    const metadata = query.metadata;\n    const textIndex = metadata.columns.findIndex((n: Column) => n.name === '__text');\n    const valueIndex = metadata.columns.findIndex((n: Column) => n.name === '__value');\n    \n    if (metadata.columns.length === 2 && textIndex !== -1 && valueIndex !== -1) {\n      const text = metadata.columns[textIndex];\n      const value = metadata.columns[valueIndex];\n      \n      return res.data.results\n        .map((rowData: any) => Object.keys(rowData).map(n => rowData[n]))\n        .map((row: any) => {\n          return {\n            text: row[text.index],\n            value: row[value.index]\n          };\n        });\n    } else {\n      throw new Error('Specify __text and __value column');      \n    }\n  }\n\n  processQueryResultTable(res: any, query: any) {\n    const frame = new MutableDataFrame({\n      refId: query.refId,\n      fields: query.metadata.columns.map((col: Column) => ({\n        name: col.name,\n        type: col.type as FieldType,\n      })),\n    });\n\n    res.data.results.forEach((rowData: any) => {\n      const row = Object.keys(rowData).map(n => rowData[n]);\n      frame.appendRow(row);\n    });\n\n    return [frame];\n  }\n\n  correctTime(dtString: string): number {\n    // SWIS sometimes return time including time zone 02:00:34.675+3:00 instead of pure UTC      \n    let dtZoneIndex = dtString.indexOf('+');            \n    if (dtZoneIndex !== -1) {        \n      dtString = dtString.substring(0, dtZoneIndex) + 'Z';\n    }\n    else if (dtString.lastIndexOf('Z') !== dtString.length-1) {\n      dtString += 'Z';\n    }\n      \n    return Date.parse(dtString);\n  }\n\n  processQueryResultMetric(res: any, query: any) {\n    const metadata = query.metadata;\n    const frames: MutableDataFrame[] = [];\n    const series: Record<string, MutableDataFrame> = {};\n\n    for (const rowData of res.data.results) {\n      const row = Object.keys(rowData).map(n => rowData[n]);\n      const date = this.correctTime(row[metadata.timeColumnIndex]);\n      \n      for (let i = 0; i < metadata.columns.length; i++) {\n        if (i === metadata.timeColumnIndex || i === metadata.metricIndex) {\n          continue;\n        }\n\n        let serieName = '';\n\n        if (metadata.metricIndex !== -1) {\n          serieName = row[metadata.metricIndex];\n        }\n\n        if (metadata.columns.length > 3 || serieName === '') {\n          if (serieName !== '') {\n            serieName += '-';\n          }\n\n          serieName += metadata.columns[i].name;\n        }\n\n        let frame = series[serieName];\n\n        if (!frame) {\n          frame = new MutableDataFrame({\n            refId: query.refId,\n            name: serieName,\n            fields: [\n              { name: 'Time', type: FieldType.time },\n              { name: 'Value', type: FieldType.number },\n            ],\n          });\n          series[serieName] = frame;\n          frames.push(frame);\n        }\n\n        const value = row[i];\n        frame.appendRow([date, value]);\n      }\n    }\n\n    return frames;\n  }\n\n  async annotationQuery(options: any) {\n    if (!options.annotation.query) {\n      throw new Error('Query missing in annotation definition');\n    }\n\n    const query = {\n      rawSql: options.annotation.query,\n      format: 'annotation',\n      metadata: {}\n    };\n    \n    return this.doQuery(query, options);\n  }\n\n  async metricFindQuery(rawSql: string, options?: any): Promise<MetricFindValue[]> {\n    const query = {\n      rawSql: rawSql,\n      format: 'search',\n      metadata: {}\n    };\n    \n    const defaultOptions = {\n      intervalMs: 0,\n      range: {\n        from: '',\n        to: ''\n      },\n      scopedVars: {}\n    };\n\n    return this.doQuery(query, { ...defaultOptions, ...options });\n  }\n\n  applyTemplateVariables(query: SwisQuery, scopedVars: ScopedVars): SwisQuery {\n    return {\n      ...query,\n      rawSql: getTemplateSrv().replace(query.rawSql, scopedVars, this.interpolateVariable),\n    };\n  }\n\n  async doRequest(options: any) {\n    options.withCredentials = this.withCredentials;\n    options.headers = this.headers;\n\n    try {\n      return await lastValueFrom(getBackendSrv().fetch(options));\n    } catch (error: any) {\n      console.error('Request failed:', error);\n      \n      if (error.status === 404) {\n        throw new Error('SWIS service is not available');\n      }\n\n      // Some query exception\n      if (error.data?.Message) {\n        throw new Error(error.data.Message);\n      }\n      \n      throw error;\n    }\n  }\n}"],"names":["module","exports","__WEBPACK_EXTERNAL_MODULE__269__","__WEBPACK_EXTERNAL_MODULE__531__","__WEBPACK_EXTERNAL_MODULE__781__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","SwisDatasource","DataSourceApi","testDatasource","response","this","doRequest","url","method","status","message","title","statusText","err","interpolateVariable","variable","multi","includeAll","replace","query","options","queries","targets","filter","item","hide","map","refId","intervalMs","maxDataPoints","rawSql","format","length","data","promises","doQuery","results","Promise","all","flat","error","console","swql","getTemplateSrv","scopedVars","param","resolveMacros","parameters","timeFrom","range","from","toISOString","timeTo","to","granularity","Math","max","floor","metadataResponse","processMetadata","dataResponse","processQueryResult","timeSpan","ms","match","group","indexOf","res","columns","metadata","timeColumnIndex","metricIndex","row","DataType","Index","push","index","name","Alias","type","translateType","Error","FieldType","number","time","boolean","string","processQueryResultTable","processQueryResultMetric","processQueryResultSearch","processQueryResultAnnotation","timeIndex","findIndex","textIndex","tagsIndex","rowData","keys","annotation","correctTime","text","tags","trim","split","valueIndex","frame","MutableDataFrame","fields","col","forEach","appendRow","dtString","dtZoneIndex","substring","lastIndexOf","Date","parse","frames","series","date","i","serieName","annotationQuery","metricFindQuery","applyTemplateVariables","withCredentials","headers","lastValueFrom","getBackendSrv","fetch","Message","constructor","instanceSettings","super","basicAuth"],"sourceRoot":""}